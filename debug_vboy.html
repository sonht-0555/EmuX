<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>EmuX VBoy Debugger - Minimal</title>
        <script src="https://unpkg.com/fflate"></script>
        <style>
            body {
                background: #111;
                color: #888;
                font-family: monospace;
                text-align: center;
            }

            #canvas {
                background: #000;
                border: 4px solid #333;
                image-rendering: pixelated;
                max-width: 90vw;
                margin: 20px auto;
                display: block;
            }

            .ui {
                background: #222;
                padding: 15px;
                display: inline-block;
                border-radius: 8px;
            }

            input,
            button {
                background: #444;
                color: #fff;
                border: 1px solid #555;
                padding: 8px;
                cursor: pointer;
            }
        </style>
    </head>
    <body>
        <h2>VBoy Debugger (Pure 2D)</h2>
        <div class="ui">
            <input type="file" id="romInput">
            <button id="startBtn" disabled>Start Core</button>
        </div>
        <canvas id="canvas"></canvas>

        <script>
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', {alpha: false});
            let romData = null;

            document.getElementById('romInput').onchange = async (e) => {
                romData = new Uint8Array(await e.target.files[0].arrayBuffer());
                document.getElementById('startBtn').disabled = false;
            };

            document.getElementById('startBtn').onclick = async () => {
                const resp = await fetch('https://raw.githubusercontent.com/sonht-0555/EmuX/builds/vboy.zip');
                const files = fflate.unzipSync(new Uint8Array(await resp.arrayBuffer()));
                let js, wasm;
                for (let f in files) {if (f.endsWith('.js')) js = new TextDecoder().decode(files[f]); if (f.endsWith('.wasm')) wasm = files[f];}

                window.Module = {
                    wasmBinary: wasm, canvas: canvas,
                    locateFile: () => URL.createObjectURL(new Blob([wasm], {type: 'application/wasm'})),
                    onRuntimeInitialized: () => {
                        console.log("WASM Ready");
                        const setup = [
                            ["retro_set_environment", env_cb, "iii"],
                            ["retro_set_video_refresh", video_cb, "viiii"],
                            ["retro_set_audio_sample", (l, r) => { }, "vii"],
                            ["retro_set_audio_sample_batch", (d, f) => f, "iii"],
                            ["retro_set_input_poll", () => { }, "v"],
                            ["retro_set_input_state", () => 0, "iiiii"]
                        ];
                        setup.forEach(([n, f, s]) => {
                            const func = Module[n] || Module["_" + n] || (Module.asm && Module.asm[n]);
                            if (func) func(Module.addFunction(f, s));
                        });

                        Module._retro_init();
                        const path = "/game.vb";
                        Module.FS.writeFile(path, romData);

                        // Fix: Allocate memory for ROM and Game Info
                        const rPtr = Module._malloc(romData.length);
                        Module.HEAPU8.set(romData, rPtr);

                        const info = Module._malloc(16);
                        const pPtr = Module._malloc(path.length + 1);
                        Module.stringToUTF8(path, pPtr, path.length + 1);

                        // [path, data, size, meta]
                        Module.HEAPU32.set([pPtr, rPtr, romData.length, 0], info >> 2);

                        console.log("Loading ROM...");
                        if (Module._retro_load_game(info)) {
                            console.log("ROM Loaded!");
                            const run = Module._retro_run || (Module.asm && Module.asm.retro_run);
                            const loop = () => {run(); requestAnimationFrame(loop);};
                            loop();
                        }
                    }
                };
                const s = document.createElement('script'); s.textContent = js; document.body.appendChild(s);
            };

            function env_cb(cmd, data) {
                if (cmd === 1) {Module.pixelFormat = Module.HEAP32[data >> 2]; return 1;}
                if (cmd === 15) {Module.HEAP32[(data >> 2) + 1] = 0; return 1;}
                return [9, 10, 21].includes(cmd) ? 1 : 0;
            }

            let autoX = 0, autoY = 0, calib = false;
            function video_cb(data, w, h, pitch) {
                if (!data) return;
                const shift = Module.pixelFormat === 1 ? 2 : 1;
                const heap = shift === 2 ? Module.HEAP32 : Module.HEAPU16;
                const line = pitch >> shift;
                const skip = 2; // [Logic 1]: Filter left eye only

                // [Logic 2]: Smart Centering
                if (!calib) {
                    let maxX = 0, minX = 9999;
                    for (let y = 40; y < h - 40; y++) {
                        const row = (data >> shift) + y * line;
                        for (let x = 0; x < Math.min(line, 1024); x++) {
                            if (heap[row + x] !== 0) {
                                if (x < minX) minX = x; if (x > maxX) maxX = x;
                            }
                        }
                    }
                    if (minX !== 9999) {
                        const contentW = (maxX - minX) / skip;
                        autoX = minX - Math.floor((384 - contentW) / 2) * skip;
                        calib = true;
                    }
                }

                if (canvas.width !== 384) {canvas.width = 384; canvas.height = 224;}
                const img = ctx.createImageData(384, 224), d32 = new Uint32Array(img.data.buffer);

                for (let y = 0; y < 224; y++) {
                    const r = (data >> shift) + (y + autoY) * line;
                    const row = y * 384;
                    for (let x = 0; x < 384; x++) {
                        const c = heap[r + autoX + x * skip];
                        // [Logic 3]: 0RGB1555 Original Palette
                        const r1 = ((c >> 10) & 0x1F) << 3, g1 = ((c >> 5) & 0x1F) << 3, b1 = (c & 0x1F) << 3;
                        d32[row + x] = 0xFF000000 | (b1 << 16) | (g1 << 8) | r1;
                    }
                }
                ctx.putImageData(img, 0, 0);
            }
        </script>
    </body>
</html>