async function inputGame(e){const t=e.target.files[0],a=storeForFilename(t.name);await emuxDB(await t.arrayBuffer(),t.name),"games"===a&&await initCore(t)}async function loadGame(e){const t=await emuxDB(e),a=new File([t],e);await initCore(a)}async function saveState(e=1){if(!isRunning)return;const t=Module._retro_serialize_size(),a=Module._malloc(t);if(Module._retro_serialize(a,t)){const n=new Uint8Array(Module.HEAPU8.buffer,a,t).slice();await emuxDB(n,`${gameName}.ss${e}`),await message(`[ss${e}]_Recorded!`,1e3)}Module._free(a)}async function loadState(e=1){if(!isRunning)return;const t=await emuxDB(`${gameName}.ss${e}`);if(t){const a=Module._malloc(t.length);Module.HEAPU8.set(t,a),Module._retro_unserialize(a,t.length),Module._free(a),await message(`[ss${e}]_Loaded!`,1e3)}}async function timer(e){if(e){if(timerId)return;timerId=setInterval(()=>{seconds++,60===seconds&&(seconds=0,minutes++),60===minutes&&(minutes=0,hours++);const e=minutes.toString().padStart(2,"0"),t=(seconds%60).toString().padStart(2,"0");document.querySelector("time1").textContent=`${hours}h${e}.${t}`,count1++,60===count1&&(autoSave(),count1=0)},1e3)}else timerId&&(clearInterval(timerId),timerId=null)}async function autoSave(){await saveState(),await message(`[${recCount}]_Recorded!`),recCount++}async function resumeGame(){timer(!0),isRunning=!0,!audioContext||"suspended"!==audioContext.state&&"interrupted"!==audioContext.state||audioContext.resume(),fadeAudioIn(),message("[_] Resumed!")}async function pauseGame(){timer(!1),isRunning=!1,audioGainNode&&(audioGainNode.gain.value=0),message("[_] Paused!")}async function rebootGame(){location.reload()}