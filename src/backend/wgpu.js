let gpuDevice,gpuQueue,contextMain,contextBottom,renderPipeline,bindGroupMain,bindGroupBottom,textureMain,textureBottom,lastMainFrame,lastBottomFrame,lastView16as32,lastMain16,sourceView32,lastMainFramePtr=0,lastBottomFramePtr=0,gpuInitializing=null,formatIs32=!0;const shaderSource="\n    struct Config { is32: u32, width: f32, height: f32, pad: u32 };\n    @group(0) @binding(0) var<uniform> config: Config;\n    @group(0) @binding(1) var texture32: texture_2d<f32>;\n    @group(0) @binding(2) var texture16: texture_2d<u32>;\n    struct VertexOutput { @builtin(position) position: vec4f, @location(0) uv: vec2f };\n    @vertex fn vs(@builtin(vertex_index) index: u32) -> VertexOutput {\n        var pos = array<vec2f, 6>(vec2f(-1,-1), vec2f(1,-1), vec2f(-1,1), vec2f(-1,1), vec2f(1,-1), vec2f(1,1));\n        var uv = array<vec2f, 6>(vec2f(0,1), vec2f(1,1), vec2f(0,0), vec2f(0,0), vec2f(1,1), vec2f(1,0));\n        var out: VertexOutput;\n        out.position = vec4f(pos[index], 0.0, 1.0);\n        out.uv = uv[index];\n        return out;\n    }\n    @fragment fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n        let coords = vec2i(uv * vec2f(config.width, config.height));\n        if (config.is32 == 1u) {\n            let color = textureLoad(texture32, coords, 0);\n            return vec4f(color.b, color.g, color.r, 1.0);\n        }\n        let raw = textureLoad(texture16, coords, 0).r;\n        return vec4f(f32((raw >> 11u) & 0x1Fu) * 0.032258, f32((raw >> 5u) & 0x3Fu) * 0.015873, f32(raw & 0x1Fu) * 0.032258, 1.0);\n    }\n";async function initGPU(e,t){if(!navigator.gpu)return!1;const r=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!r)return!1;gpuDevice=await r.requestDevice(),gpuQueue=gpuDevice.queue;const i=navigator.gpu.getPreferredCanvasFormat();contextMain=e.getContext("webgpu"),contextMain.configure({device:gpuDevice,format:i,alphaMode:"opaque"}),t&&(contextBottom=t.getContext("webgpu"),contextBottom.configure({device:gpuDevice,format:i,alphaMode:"opaque"}));const n=gpuDevice.createShaderModule({code:shaderSource});return renderPipeline=gpuDevice.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vs"},fragment:{module:n,entryPoint:"fs",targets:[{format:i}]},primitive:{topology:"triangle-list"}}),!0}function createTexture(e,t,r){return gpuDevice.createTexture({size:[e,t,1],format:r?"rgba8unorm":"r16uint",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})}function recordDraw(e,t,r){const i=r.beginRenderPass({colorAttachments:[{view:e.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});i.setPipeline(renderPipeline),i.setBindGroup(0,t),i.draw(6),i.end()}function render32(e,t,r,i,n,a,o,u,s,c,d){frameCount++;const l=Module._retro_is_dirty||Module.asm&&Module.asm._retro_is_dirty||Module.instance&&Module.instance.exports&&Module.instance.exports._retro_is_dirty||Module.instance&&Module.instance.exports&&Module.instance.exports.retro_is_dirty;if(l&&i){if(l(e.byteOffset+(t<<2),i,s<<2))return r.set(e.subarray(t,t+s)),gpuQueue.writeTexture({texture:a},r,{bytesPerRow:4*o},{width:o,height:u}),void recordDraw(n,c,d)}else{const i=new BigUint64Array(e.buffer,e.byteOffset+(t<<2),s>>1),l=new BigUint64Array(r.buffer,0,s>>1);for(let f=i.length-1;f>=0;f--)if(i[f]!==l[f])return r.set(e.subarray(t,t+s)),gpuQueue.writeTexture({texture:a},r,{bytesPerRow:4*o},{width:o,height:u}),void recordDraw(n,c,d)}skippedFrames++}function render16(e,t,r,i,n,a,o,u,s,c,d){frameCount++;const l=o>>1,f=s>>1,g=Module._retro_is_dirty||Module.asm&&Module.asm._retro_is_dirty||Module.instance&&Module.instance.exports&&Module.instance.exports._retro_is_dirty||Module.instance&&Module.instance.exports&&Module.instance.exports.retro_is_dirty;if(g&&i){if(g(e.byteOffset,i,o*u<<1)){if(o===s)t.set(e);else for(let r=0;r<u;r++)t.set(e.subarray(r*f,r*f+l),r*l);return gpuQueue.writeTexture({texture:a},r,{bytesPerRow:2*o},{width:o,height:u}),void recordDraw(n,c,d)}}else for(let i=u-1;i>=0;i--){const g=i*f,p=i*l;for(let i=l-1;i>=0;i--)if(e[g+i]!==t[p+i]){if(o===s)t.set(e);else for(let r=0;r<u;r++)t.set(e.subarray(r*f,r*f+l),r*l);return gpuQueue.writeTexture({texture:a},r,{bytesPerRow:2*o},{width:o,height:u}),void recordDraw(n,c,d)}}skippedFrames++}function renderNDS(e,t,r,i){const n=r>>1,a=t*n,o=Module.HEAPU8.buffer;if(cachedWidth!==t||cachedHeight!==n){cachedWidth=t,cachedHeight=n,Module.canvas.width=canvasB.width=t,Module.canvas.height=canvasB.height=n,textureMain=createTexture(t,n,!0),textureBottom=createTexture(t,n,!0);const e=renderPipeline.getBindGroupLayout(0),r=createTexture(1,1,!1),i=i=>{const a=gpuDevice.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return gpuQueue.writeBuffer(a,0,new Uint32Array([1])),gpuQueue.writeBuffer(a,4,new Float32Array([t,n])),gpuDevice.createBindGroup({layout:e,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:i.createView()},{binding:2,resource:r.createView()}]})};bindGroupMain=i(textureMain),bindGroupBottom=i(textureBottom),lastMainFramePtr&&Module._free(lastMainFramePtr),lastBottomFramePtr&&Module._free(lastBottomFramePtr),lastMainFramePtr=Module._malloc(a<<2),lastBottomFramePtr=Module._malloc(a<<2),lastMainFrame=new Uint32Array(Module.HEAPU8.buffer,lastMainFramePtr,a),lastBottomFrame=new Uint32Array(Module.HEAPU8.buffer,lastBottomFramePtr,a),sourceView32=null,window.gameView&&gameView(gameName)}sourceView32&&sourceView32.buffer===o&&ndsPointer===e||(ndsPointer=e,sourceView32=new Uint32Array(o,e,t*r)),render32(sourceView32,0,lastMainFrame,lastMainFramePtr,contextMain,textureMain,t,n,a,bindGroupMain,i),render32(sourceView32,a,lastBottomFrame,lastBottomFramePtr,contextBottom,textureBottom,t,n,a,bindGroupBottom,i)}window.activeRenderFn=async function(e,t,r,i){if(!gpuDevice){if(gpuInitializing||(gpuInitializing=initGPU(Module.canvas,Module.isNDS?canvasB:null)),!await gpuInitializing)return;Module.isNDS&&(page02.style.paddingTop="5px",canvasB.style.display="block",joypad.style.justifyContent="center",joy.style.display="none")}const n=gpuDevice.createCommandEncoder(),a=i===t<<2,o=Module.HEAPU8.buffer;if(Module.isNDS)renderNDS(e,t,r,n);else{if(t!==cachedWidth||r!==cachedHeight||a!==formatIs32){cachedWidth=t,cachedHeight=r,cachedPitch=i,formatIs32=a,cachedBuffer=null,Module.canvas.width=t,Module.canvas.height=r,textureMain=createTexture(t,r,a);const e=createTexture(1,1,!a),n=gpuDevice.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});gpuQueue.writeBuffer(n,0,new Uint32Array([a?1:0])),gpuQueue.writeBuffer(n,4,new Float32Array([t,r])),bindGroupMain=gpuDevice.createBindGroup({layout:renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:(a?textureMain:e).createView()},{binding:2,resource:(a?e:textureMain).createView()}]});const o=t*r;lastMainFramePtr&&Module._free(lastMainFramePtr),a?(lastMainFramePtr=Module._malloc(o<<2),lastMainFrame=new Uint32Array(Module.HEAPU8.buffer,lastMainFramePtr,o)):(lastMainFramePtr=Module._malloc(o<<1),lastView16as32=new Uint32Array(Module.HEAPU8.buffer,lastMainFramePtr,o>>1),lastMain16=new Uint16Array(Module.HEAPU8.buffer,lastMainFramePtr,o)),window.gameView&&gameView(gameName)}o===cachedBuffer&&e===cachedPointer||(cachedBuffer=o,cachedPointer=e,sourceView32=new Uint32Array(o,e,i*r>>2)),a?render32(sourceView32,0,lastMainFrame,lastMainFramePtr,contextMain,textureMain,t,r,t*r,bindGroupMain,n):render16(sourceView32,lastView16as32,lastMain16,lastMainFramePtr,contextMain,textureMain,t,r,i>>1,bindGroupMain,n)}gpuQueue.submit([n.finish()]),logSkip()},console.log("wgpu.js loaded");