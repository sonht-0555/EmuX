const AWS_ALGORITHM = "AWS4-HMAC-SHA256", AWS_REQUEST_TYPE = "aws4_request", S3_SERVICE = "s3", LIST_TYPE = "2", UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD", DEFAULT_CONTENT_TYPE = "application/octet-stream", HEADER_AMZ_CONTENT_SHA256 = "x-amz-content-sha256", HEADER_AMZ_DATE = "x-amz-date", HEADER_HOST = "host", HEADER_AUTHORIZATION = "authorization", HEADER_CONTENT_TYPE = "content-type", HEADER_CONTENT_LENGTH = "content-length", ENCODR = new TextEncoder, HEX_CHARS = new Uint8Array([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]), getByteSize = e => "string" == typeof e ? ENCODR.encode(e).byteLength : e instanceof ArrayBuffer || e instanceof Uint8Array ? e.byteLength : e instanceof Blob || e instanceof File ? e.size : Number.NaN, hexFromBuffer = e => {const t = new Uint8Array(e), n = new Uint8Array(2 * t.length); for (let e = 0, s = 0; e < t.length; e++)n[s++] = HEX_CHARS[t[e] >> 4], n[s++] = HEX_CHARS[15 & t[e]]; return String.fromCodePoint(...n);}, sha256 = async e => globalThis.crypto.subtle.digest("SHA-256", "string" == typeof e ? ENCODR.encode(e) : e), hmac = async (e, t) => {const n = await globalThis.crypto.subtle.importKey("raw", "string" == typeof e ? ENCODR.encode(e) : e, {name: "HMAC", hash: "SHA-256"}, !1, ["sign"]); return globalThis.crypto.subtle.sign("HMAC", n, "string" == typeof t ? ENCODR.encode(t) : t);}, awsEncode = (e, t = !0) => {let n = encodeURIComponent(e).replace(/[!'()*]/g, (e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`)); return t || (n = n.replace(/%2F/g, "/")), n;}, parseXml = e => {const t = e.replace(/<\?xml[^?]*\?>\s*/, ""), n = /<([A-Za-z_][\w\-.]*)[^>]*>([\s\S]*?)<\/\1>/gm, s = {}; let a; for (; null !== (a = n.exec(t));) {const e = a[1], t = a[2], n = t.includes("<") ? parseXml(t) : t.replace(/&(quot|apos|lt|gt|amp);/g, (e => ({"&quot;": '"', "&apos;": "'", "&lt;": "<", "&gt;": ">", "&amp;": "&"}[e]))), r = s[e]; void 0 === r ? s[e] = n : Array.isArray(r) ? r.push(n) : s[e] = [r, n];} return s;}; class S3mini {#e; #t; constructor({accessKeyId: e, secretAccessKey: t, endpoint: n, region: s = "auto"}) {this.#e = e, this.#t = t, this.endpoint = new URL(n.endsWith("/") ? n.slice(0, -1) : n), this.region = s;} async _sign(e, t, n = {}, s = {}) {const a = (new Date).toISOString().replace(/[:\-]/g, "").split(".")[0] + "Z", r = a.slice(0, 8), o = `${r}/${this.region}/s3/aws4_request`; let c = this.endpoint.pathname; t && (c = c.endsWith("/") ? `${c}${t.replace(/^\/+/, "")}` : `${c}/${t.replace(/^\/+/, "")}`); const i = awsEncode(c, !1); s["x-amz-date"] = a, s["x-amz-content-sha256"] = UNSIGNED_PAYLOAD, s.host = this.endpoint.host; let h = "", l = ""; const A = Object.keys(s).sort(); for (const e of A) {const t = e.toLowerCase();["authorization", "content-length", "user-agent", "connection", "expect"].includes(t) || (h += `${t}:${String(s[e]).trim()}\n`, l += (l ? ";" : "") + t);} const E = `${e}\n${i}\n${Object.keys(n).sort().map((e => `${awsEncode(e)}=${awsEncode(n[e])}`)).join("&")}\n${h}\n${l}\n${UNSIGNED_PAYLOAD}`, d = `${AWS_ALGORITHM}\n${a}\n${o}\n${hexFromBuffer(await sha256(E))}`, u = await hmac(`AWS4${this.#t}`, r), y = await hmac(u, this.region), p = await hmac(y, "s3"), g = await hmac(p, "aws4_request"), T = hexFromBuffer(await hmac(g, d)); return s.authorization = `${AWS_ALGORITHM} Credential=${this.#e}/${o}, SignedHeaders=${l}, Signature=${T}`, {url: `${this.endpoint.protocol}//${this.endpoint.host}${i}`, headers: s};} async listObjects(e = "/", t = "") {const n = {"list-type": "2", prefix: t, delimiter: e}, {url: s, headers: a} = await this._sign("GET", "", n), r = Object.keys(n).sort().map((e => `${awsEncode(e)}=${awsEncode(n[e])}`)).join("&"); return fetch(`${s}?${r}`, {headers: a}).then((e => e.text())).then((e => {const t = parseXml(e), n = (t.ListBucketResult || t).Contents || []; return Array.isArray(n) ? n : [n];}));} async getObjectArrayBuffer(e) {const {url: t, headers: n} = await this._sign("GET", e); return fetch(t, {headers: n}).then((e => 200 === e.status ? e.arrayBuffer() : null));} async putAnyObject(e, t, n = DEFAULT_CONTENT_TYPE) {const s = getByteSize(t), {url: a, headers: r} = await this._sign("PUT", e, {}, {"content-type": n, "content-length": s}); return fetch(a, {method: "PUT", headers: r, body: t});} async deleteObject(e) {const {url: t, headers: n} = await this._sign("DELETE", e); return fetch(t, {method: "DELETE", headers: n});} } window.S3mini = S3mini;