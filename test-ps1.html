<!DOCTYPE html>
<html>
<head>
    <title>Raw PS1 Test</title>
    <style>
        body { background: #111; color: #fff; text-align: center; font-family: sans-serif; }
        canvas { background: #000; image-rendering: pixelated; width: 100%; max-width: 640px; }
        #status { color: #0f0; margin: 10px; font-family: monospace; }
        .box { border: 1px solid #333; padding: 20px; display: inline-block; margin-top: 20px; }
    </style>
</head>
<body>
    <h3>PS1 Raw Tester (No Project JS)</h3>
    <div class="box">
        <input type="file" id="romInput">
        <button id="startBtn">LOAD & START</button>
    </div>
    <div id="status">Ready</div>
    <canvas id="canvas"></canvas>

    <script>
        const status = (m) => document.getElementById('status').innerText = m;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isRunning = false;

        // --- RAW VIDEO CALLBACK (2D Canvas) ---
        function video_cb(pointer, width, height, pitch) {
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
            }

            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;
            const bpp = pitch / width; // Bytes per pixel

            if (bpp === 4) {
                // 32-bit XRGB8888 (PS1 Standard)
                const src = new Uint32Array(Module.HEAPU8.buffer, pointer, width * height);
                for (let i = 0; i < src.length; i++) {
                    const c = src[i];
                    const r = (c >> 16) & 0xFF;
                    const g = (c >> 8) & 0xFF;
                    const b = c & 0xFF;
                    const idx = i * 4;
                    data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
                }
            } else {
                // 16-bit RGB565 (Fall-back)
                const src = new Uint16Array(Module.HEAPU8.buffer, pointer, width * height);
                for (let i = 0; i < src.length; i++) {
                    const c = src[i];
                    const idx = i * 4;
                    data[idx] = ((c >> 11) & 0x1F) << 3;
                    data[idx+1] = ((c >> 5) & 0x3F) << 2;
                    data[idx+2] = (c & 0x1F) << 3;
                    data[idx+3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        // --- DUMMY CALLBACKS ---
        function audio_cb(left, right) {}
        function audio_batch_cb(data, frames) { return frames; }
        function input_poll_cb() {}
        function input_state_cb(port, device, index, id) { return 0; }
        function env_cb(cmd, data) {
            if (cmd === 10) return 1; // GET_CAN_DUPE
            if (cmd === 31 || cmd === 37) { // GEOMETRY
                const w = Module.HEAP32[data >> 2], h = Module.HEAP32[(data >> 2) + 1];
                if (w > 0 && h > 0) { canvas.width = w; canvas.height = h; }
                return 1;
            }
            return 0;
        }

        document.getElementById('startBtn').onclick = async () => {
            const file = document.getElementById('romInput').files[0];
            if (!file) return alert("Please select a .bin / .iso file");

            status("Reading ROM file...");
            const romData = new Uint8Array(await file.arrayBuffer());

            window.Module = {
                canvas: canvas,
                locateFile: (path) => path.endsWith('.wasm') ? './src/core/ps1.wasm' : path,
                async onRuntimeInitialized() {
                    status("VFS Setup...");
                    const romPath = "/game.bin";
                    Module.FS.writeFile(romPath, romData);

                    status("Initialize Core...");
                    const infoPtr = Module._malloc(16);
                    const pathPtr = Module._malloc(256);
                    Module.stringToUTF8(romPath, pathPtr, 256);

                    // Register Callbacks
                    [[_retro_set_environment, env_cb, "iii"], 
                     [_retro_set_video_refresh, video_cb, "viiii"], 
                     [_retro_set_audio_sample, audio_cb, "vii"], 
                     [_retro_set_audio_sample_batch, audio_batch_cb, "iii"], 
                     [_retro_set_input_poll, input_poll_cb, "v"], 
                     [_retro_set_input_state, input_state_cb, "iiiii"]
                    ].forEach(([f, cb, sig]) => f(Module.addFunction(cb, sig)));

                    Module._retro_init();

                    // Load Game
                    Module.HEAP32[infoPtr >> 2] = pathPtr;
                    Module.HEAP32[(infoPtr >> 2) + 1] = 0;
                    Module.HEAP32[(infoPtr >> 2) + 2] = 0;
                    Module.HEAP32[(infoPtr >> 2) + 3] = 0;
                    
                    if (Module._retro_load_game(infoPointer = infoPtr)) {
                        status("RUNNING (Interpreter Mode)");
                        isRunning = true;
                        (function loop() { 
                            if(isRunning) { 
                                Module._retro_run(); 
                                requestAnimationFrame(loop); 
                            } 
                        })();
                    } else {
                        status("Core failed to load game.");
                    }
                }
            };

            const script = document.createElement('script');
            script.src = "./src/core/ps1.js";
            document.body.appendChild(script);
        };
    </script>
</body>
</html>
