<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>FBNeo WASM Test</title>
    <style>
        body {
            font-family: sans-serif;
            background: #222;
            color: #fff;
            padding: 20px;
        }

        canvas {
            border: 2px solid #555;
            background: #000;
            image-rendering: pixelated;
        }

        #status {
            margin: 10px 0;
            color: #0f0;
        }

        #log {
            font-family: monospace;
            font-size: 12px;
            background: #000;
            padding: 10px;
            height: 200px;
            overflow-y: scroll;
            border: 1px solid #444;
        }

        .info {
            background: #333;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <h1>FBNeo Core Test</h1>

    <div class="info">
        <strong>FBNeo</strong> - Final Burn Neo arcade emulator<br>
        Supports 6,000+ arcade games (CPS1, CPS2, CPS3, Neo Geo, etc.)<br>
        <small>ROM format: .zip (MAME 0.187+ or FBNeo romset)</small>
    </div>

    <input type="file" id="romInput" accept=".zip">
    <div id="status">Waiting for ROM...</div>
    <div id="log"></div>
    <canvas id="canvas" width="320" height="240"></canvas>

    <!-- JSZip library for extracting ROM from ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        const logger = (msg, color = '#fff') => {
            const l = document.getElementById('log');
            const d = document.createElement('div');
            d.style.color = color;
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            l.appendChild(d);
            l.scrollTop = l.scrollHeight;
            console.log(msg);
        };

        function env_cb(cmd, data) {
            logger(`env_cb: cmd=${cmd} (0x${cmd.toString(16)})`);
            switch (cmd) {
                case 1:  // RETRO_ENVIRONMENT_SET_ROTATION
                case 11: // RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS
                case 12: // RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK
                    return 1;

                case 10: // RETRO_ENVIRONMENT_SET_PIXEL_FORMAT
                    const pixelFormat = Module.HEAP32[data >> 2];
                    logger(`  -> Pixel format set to: ${pixelFormat} (0=RGB1555, 1=XRGB8888, 2=RGB565)`, "#aaa");
                    return 1;

                case 31: // RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY
                case 9:  // RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY
                case 54: // RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY
                    const dirPtr = Module._malloc(256);
                    Module.stringToUTF8("/home/web_user/retroarch", dirPtr, 256);
                    Module.HEAP32[data >> 2] = dirPtr;
                    return 1;

                case 15: // RETRO_ENVIRONMENT_GET_VARIABLE
                    const variablePtr = Module.HEAP32[data >> 2];
                    if (!variablePtr) return 0;
                    let key = Module.UTF8ToString(variablePtr);
                    // logger(`  -> query variable: ${key}`, "#888");
                    Module.HEAP32[(data >> 2) + 1] = 0; // Value = NULL
                    return 0;

                case 27: // RETRO_ENVIRONMENT_GET_LOG_INTERFACE
                    return 0; // Return 0 to avoid variadic function signature mismatch crashes

                case 52: // RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
                    if (data) Module.HEAP32[data >> 2] = 1;
                    return 1;

                case 55: // RETRO_ENVIRONMENT_GET_CORE_OPTIONS_V2
                case 53: // RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY
                    return 0; // Fallback to older options API

                case 60: // RETRO_ENVIRONMENT_GET_VFS_INTERFACE
                    return 0;

                    return 0;

                default:
                    // console.log("env_cb: cmd=" + cmd);
                    return 0;
            }
        }
        let firstFrameReceived = false;
        // Video Callback - Cleaned up to remove spam
        function video_refresh_cb(data, w, h, p) {
            if (!data || !Module.ctx) return;

            if (!firstFrameReceived) {
                logger(`First frame received: ${w}x${h}, pitch: ${p}`, "#0f0");
                firstFrameReceived = true;
            }

            if (Module.lastW !== w || Module.lastH !== h) {
                Module.canvas.width = w;
                Module.canvas.height = h;
                Module.lastW = w;
                Module.lastH = h;
                Module.imageData = Module.ctx.createImageData(w, h);
                logger(`Video: ${w}x${h}`, "#0ff");
            }
            const bpp = p / w;
            const imgData = Module.imageData;
            const dst = imgData.data;
            if (bpp === 2) {
                const src = Module.HEAPU16.subarray(data >> 1, (data + p * h) >> 1);
                let i = 0;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const pixel = src[(y * (p >> 1)) + x];
                        dst[i++] = ((pixel >> 11) & 0x1F) * 255 / 31;
                        dst[i++] = ((pixel >> 5) & 0x3F) * 255 / 63;
                        dst[i++] = (pixel & 0x1F) * 255 / 31;
                        dst[i++] = 255;
                    }
                }
            } else if (bpp === 4) {
                const src = Module.HEAPU32.subarray(data >> 2, (data + p * h) >> 2);
                let i = 0;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const pixel = src[(y * (p >> 2)) + x];
                        dst[i++] = (pixel >> 16) & 0xFF;
                        dst[i++] = (pixel >> 8) & 0xFF;
                        dst[i++] = pixel & 0xFF;
                        dst[i++] = 255;
                    }
                }
            }
            Module.ctx.putImageData(imgData, 0, 0);
        }

        function audio_cb(l, r) { }
        function audio_batch_cb(d, f) { return f; }
        function input_poll_cb() { }
        function input_state_cb(p, d, i, id) { return 0; }

        document.getElementById('romInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            logger(`Loading: ${file.name}`, "#0ff");
            document.getElementById('status').innerText = `Extracting ${file.name}...`;

            try {
                // Read ZIP file
                const zipData = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(zipData);

                logger(`ZIP opened, found ${Object.keys(zip.files).length} files`, "#0ff");

                // Extract all files from ZIP
                const extractedFiles = [];
                for (const [filename, zipEntry] of Object.entries(zip.files)) {
                    if (!zipEntry.dir) {
                        const fileData = await zipEntry.async('uint8array');
                        extractedFiles.push({ name: filename, data: fileData });
                        logger(`  Extracted: ${filename} (${fileData.length} bytes)`, "#888");
                    }
                }

                if (extractedFiles.length === 0) {
                    throw new Error("No files found in ZIP");
                }

                // Store for later use
                window.romData = extractedFiles;
                window.romFile = file;

                window.Module = {
                    canvas: document.getElementById('canvas'),
                    ctx: document.getElementById('canvas').getContext('2d'),
                    locateFile: (p) => p.endsWith('.wasm') ? 'src/core/fbneo_libretro.wasm' : p,

                    preRun: [function () {
                        // Inject string_to_lower function before WASM runs
                        Module['string_to_lower'] = function (str_ptr) {
                            if (!str_ptr) return 0;
                            try {
                                const str = Module.UTF8ToString(str_ptr);
                                const lower = str.toLowerCase();
                                const len = Module.lengthBytesUTF8(lower) + 1;
                                const ptr = Module._malloc(len);
                                Module.stringToUTF8(lower, ptr, len);
                                logger(`string_to_lower: "${str}" -> "${lower}"`, "#888");
                                return ptr;
                            } catch (e) {
                                console.error('string_to_lower error:', e);
                                return str_ptr;
                            }
                        };
                        // Also define with underscore prefix for C name mangling
                        Module['_string_to_lower'] = Module['string_to_lower'];

                        // Inject string_replace_substring function
                        Module['string_replace_substring'] = function (inPtr, patternPtr, byPtr) {
                            const input = Module.UTF8ToString(inPtr);
                            const pattern = Module.UTF8ToString(patternPtr);
                            const by = Module.UTF8ToString(byPtr);
                            const result = input.split(pattern).join(by);
                            const resPtr = Module._malloc(result.length + 1);
                            Module.stringToUTF8(result, resPtr, result.length + 1);
                            logger(`string_replace_substring: "${input}" (pattern: "${pattern}", by: "${by}") -> "${result}"`, "#888");
                            return resPtr;
                        };
                        Module['_string_replace_substring'] = Module['string_replace_substring'];
                    }],

                    onRuntimeInitialized: async function () {
                        logger("WASM Initialized", "#0f0");
                        try {
                            // Write all extracted ROM files to virtual FS
                            for (const file of window.romData) {
                                Module.FS.writeFile(`/${file.name}`, file.data);
                                logger(`  Written: /${file.name} (${file.data.length} bytes)`, "#888");
                            }

                            // Also write the original ZIP (FBNeo might need it)
                            const zipPath = `/${window.romFile.name}`;
                            const zipBuffer = await window.romFile.arrayBuffer();
                            Module.FS.writeFile(zipPath, new Uint8Array(zipBuffer));
                            logger(`ROM files written to virtual FS`, "#0f0");

                            // Prepare retro_game_info with ZIP path
                            const namePtr = Module._malloc(zipPath.length + 1);
                            Module.stringToUTF8(zipPath, namePtr, zipPath.length + 1);

                            // Arcade cores usually want the path, not the data buffer
                            const info = Module._malloc(16);
                            Module.HEAP32[(info >> 2) + 0] = namePtr; // path
                            Module.HEAP32[(info >> 2) + 1] = 0;       // data (null)
                            Module.HEAP32[(info >> 2) + 2] = 0;       // size (0)
                            Module.HEAP32[(info >> 2) + 3] = 0;       // meta (null)

                            logger("Registering callbacks...");
                            Module._retro_set_environment(Module.addFunction(env_cb, "iii"));
                            Module._retro_set_video_refresh(Module.addFunction(video_refresh_cb, "viiii"));
                            Module._retro_set_audio_sample(Module.addFunction(audio_cb, "vii"));
                            Module._retro_set_audio_sample_batch(Module.addFunction(audio_batch_cb, "iii"));
                            Module._retro_set_input_poll(Module.addFunction(input_poll_cb, "v"));
                            Module._retro_set_input_state(Module.addFunction(input_state_cb, "iiiii"));

                            logger("Initializing core...");
                            Module._retro_init();

                            logger("Loading game with ccall...");
                            try {
                                logger("Calling retro_load_game...");
                                const res = Module.ccall('retro_load_game', 'number', ['number'], [info]);
                                logger(`retro_load_game returned: ${res}`);

                                if (res) {
                                    logger(`Game loaded successfully!`, "#0f0");

                                    // Get AV info
                                    try {
                                        const avInfo = Module._malloc(32);
                                        logger("Calling retro_get_system_av_info...");
                                        Module._retro_get_system_av_info(avInfo);
                                        logger("retro_get_system_av_info succeeded");

                                        const width = Module.HEAP32[(avInfo >> 2) + 2];
                                        const height = Module.HEAP32[(avInfo >> 2) + 3];
                                        logger(`Video: ${width}x${height}`, "#0ff");
                                        Module._free(avInfo);
                                    } catch (e) {
                                        logger(`AV Info error: ${e.message}`, "#f00");
                                    }

                                    document.getElementById('status').innerText = "Running!";
                                    const loop = () => {
                                        Module._retro_run();
                                        requestAnimationFrame(loop);
                                    };
                                    requestAnimationFrame(loop);
                                } else {
                                    logger("Failed to load game (core returned 0)", "#f00");
                                    document.getElementById('status').innerText = "Load failed - Check ROM compatibility";
                                }
                            } catch (e) {
                                logger(`Load error: ${e.message}`, "#f00");
                                console.error(e);
                                if (e.message.includes("signature mismatch")) {
                                    logger("CRITICAL: Signature mismatch - Core needs rebuild", "#ff0");
                                }
                            }
                        } catch (e) {
                            logger("Error: " + e.message, "#f00");
                            console.error(e);
                        }
                    }
                };

                const script = document.createElement('script');
                script.src = 'src/core/fbneo_libretro.js?v=' + Date.now();
                document.body.appendChild(script);
            } catch (e) {
                logger(`ZIP extraction error: ${e.message}`, "#f00");
                console.error(e);
                document.getElementById('status').innerText = `Error: ${e.message}`;
            }
        });
    </script>
</body>

</html>